
[Language Basics](#language-basics)

- [Comments](#comments---language-basics)

- [Primitive Data Types](#primitive-data-types---language-basics)

- [Arrays](#arrays---language-basics)

- [Copying Arrays](#copying-arrays---language-basics)

[Operators](#operators)

[Input and Output](#input-and-output)

[Control Flow Statements](#control-flow-statements)

[Numbers and Strings](#numbers-and-strings)

[Characters](#characters)

[Strings](#strings)

[Autoboxing and Unboxing](#autoboxing-and-unboxing)

[Generics](#generics)

[Essential Java Class](#essential-java-class)

[Exceptions](#exceptions)

[Basic I/O](#basic-io)

[File I/O](#file-io)

[Concurrency](#concurrency)

[Regular Expressions](#regular-expressions)

[Collections](#collections)

[Collections](#collections)



[Continue Statement - Control Flow Statements]

[Return Statement - Control Flow Statements]

[Classes and Objects]

[Declaring Classes - Classes and Objects]

[Declaring Member Variables Fields - Classes and Objects]

[Defining Methods - Classes and Objects]

[Overloading Methods - Classes and Objects]

[Creating Objects - Classes and Objects]

[Using Objects - Classes and Objects]

[More on Classes - Classes and Objects]

[Returning a Value from a Method - Classes and Objects]

[Returning a Value from a Method - Classes and Objects]

[Nested Classes - Classes and Objects]

[Enum Types - Classes and Objects]

[Interfaces and Inheritance]

[Interfaces - Interfaces and Inheritance]

[Defining an Interface - Interfaces and Inheritance]

[Implementing an Interface - Interfaces and Inheritance]

[Using an Interface as a Type - Interfaces and Inheritance]

[Rewriting Interfaces - Interfaces and Inheritance]

[Inheritance - Interfaces and Inheritance]

[Overriding and Hiding Methods - Interfaces and Inheritance]

[Polymorphism - Interfaces and Inheritance]

[Object as a Superclass - Interfaces and Inheritance]

[Abstract Methods and Classes - Interfaces and Inheritance]

[Numbers and Strings]

- [Numbers - Numbers and Strings]

- [The Numbers Classes - Numbers and Strings]

- [Formating Numeric Print Output - Numbers and Strings]

- [The DecimalFormat Class - Numbers and Strings]

- [Beyond Basic Arithmetic - Numbers and Strings]

# Characters

# Strings

- [Converting Between Numbers and Strings - Strings]

- [Manipulating Characters in a String - Strings]

- [Comparing Strings and Portions of Strings - Strings]

- [The StringBuilder Class - Strings]

# Autoboxing and Unboxing

- [Autoboxing - Autoboxing and Unboxing]

- [Unboxing - Autoboxing and Unboxing]

# Generics

- [Generic Types - Generics]

- [A Simple Box Class - Generics]

- [A Generic Version of the Box Class - Generics]

- [Type Parameter Naming Conventions - Generics]

- [Invoking and Instantiating a Generic Type - Generics]

- [The Diamond - Generics]

- [Multiple Type Parameters - Generics]

- [The Diamond - Generics]

- [Parameterized Types - Generics]

- [Raw Types - Generics]

- [Generic Methods - Generics]

- [Bounded Type Parameters - Generics]

- [Multiple Bounds - Generics]

- [Generic Methods and Bounded Type Parameters - Generics]

- [Generics, Inheritance, and Subtypes - Generics]

- [Generic Classes and Subtyping - Generics]

- [Type Inference - Generics]

- [Type Inference and Generic Contructors of Generic and Non-Generic Classes - Generics]

## Wildcards - Generics

## Upper Bounded Wildcards - Generics

## Unbounded Wildcards - Generics

## Lower Bounded Wildcards - Generics

## Wildcards and Subtyping - Generics

## Wildcard Capture and Helper Methods - Generics

## Type Erasure - Generics

## Effects of Type Erasure and Bridge Methods - Generics

# Packages

## Using Package Memebers - Packages

## Refer to the member by its fully qualified name - Packages

## Import the package member - Packages

## Import the member’s entire package - Packages

## Apparent Hierarchies of Packages - Packages

## Name Ambiguities - Packages

## The Static Import Statement - Packages

## The Static Import Statement - Packages

# Essential Java Class

# Exceptions

## Catching and Handling Exceptions - Exceptions

## The Try Block - Exceptions

## The Catch Blocks - Exceptions

## The finally Block - Exceptions

## The try-with-resources Statement - Exceptions

## Putting It All Together - Exceptions

## Specifying the Exceptions Thrown by a Method - Exceptions

## How to Throw Exceptions - Exceptions

## Chained Exceptions - Exceptions

## Accessing Stack Trace Information - Exceptions

## Logging API - Exceptions

## Creating Exception Classes - Exceptions

# Basic I/O

## Using Byte Streams - Basic I/O

## Character Streams - Basic I/O

## Using Character Streams - Basic I/O

## Line-Oriented I/O - Basic I/O

## Buffered Streams - Basic I/O

## Scanning and Formatting - Scanning - Breaking Input into Tokens - Basic I/O

## Scanning and Formatting - Scanning - Translating Individual Tokens - Basic I/O

## Scanning and Formatting - Formatting - Basic I/O

## I/O from the Command Line - Basic I/O

## Standard Streams - Basic I/O

## The Console - Basic I/O

## Data Streams - Basic I/O

## Object Streams - Basic I/O

# File I/O

## Creating a Path - File I/O

## Retrieving Information about a Path - File I/O

## Converting a Path - File I/O

## Creating a Path Between Two Paths - File I/O

## Comparing Two Paths - File I/O

## Catching Exceptions - File I/O

## Varargs - File I/O

## Method Chaining - File I/O

## Verifying the Existence of a File or Directory - File I/O

## Checking File Accessibility - File I/O

## Checking Whether Two Paths Locate the Same File - File I/O

## Deleting a File or Directory - File I/O

## Copying a File or Directory - File I/O

## Moving a File or Directory - File I/O

## Managing Metadata - File I/O

## The OpenOptions Parameter - File I/O

## Commonly Used Methods for Small Files - File I/O

## Buffered I/O Methods for Text Files - File I/O

## Methods for Unbuffered Streams and Interoperable with java.io APIs - File I/O

## Methods for Channels and ByteBuffers - File I/O

## Methods for Creating Regular and Temporary Files - File I/O

## Random Access Files - File I/O

## Listing a File System’s Root Directories - File I/O

## Creating a Directory - File I/O

## Creating a Temporary Directory - File I/O

## Listing a Directory’s Contents - File I/O

## Filtering a Directory Listing By Using Globbing - File I/O

## Writing Your Own Directory Filter - File I/O

## Links, Symbolic or Otherwise - File I/O

## Creating a Symbolic Link - File I/O

## Creating a Hard Link - File I/O

## Detecting a Symbolic Link - File I/O

## Detecting a Symbolic Link - File I/O

## Finding the Target of a Link - File I/O

## Walking the File Tree - The FileVisitor Interface - File I/O

## Kickstarting the Process - The FileVisitor Interface - File I/O

## Considerations When Creating a FileVisitor - The FileVisitor Interface - File I/O

## Controlling the Flow - The FileVisitor Interface - File I/O

## Finding Files - The FileVisitor Interface - File I/O

## Watch Service Overview - Watching a Directory for Changes - File I/O

## Legacy File I/O Code


# Concurrency

## Defining and Starting a Thread - Concurrency

## Provide a Runnable object - Concurrency

## Subclass Thread - Concurrency

## The SimpleThreads Example - Concurrency

## The SimpleThreads Example - Concurrency

## Immutable Objects - Concurrency

## A Synchronized Class Example - Concurrency

## A Strategy for Defining Immutable Objects - Concurrency

## Lock Objects - High Level Concurrency Objects - Concurrency

## Lock Objects - High Level Concurrency Objects - Concurrency

# The Platform Environment

## Setting Up the Properties Object - The Platform Environment

## Saving Properties - The Platform Environment

## Command-Line Arguments - The Platform Environment

## Echoing Command-Line Arguments - The Platform Environment

## Parsing Numeric Command-Line Arguments - The Platform Environment

## Querying Environment Variables - The Platform Environment

## System Utilities - The Platform Environment

## Reading System Properties - The Platform Environment

## Writing System Properties - The Platform Environment

## PATH and CLASSPATH - The Platform Environment

## Checking the CLASSPATH variable (All platforms) - The Platform Environment

## Update the PATH Variable (Solaris and Linux) - The Platform Environment

# Regular Expressions

## Test Harness - Regular Expressions

## Using the split (String) Method - Regular Expressions

# Collections

## Interfaces - Collections

## The Collection Interface - Collections

## for-each Construct - Collections

## Iterators - Collections

## Collection Interface Bulk Operations - Collections

## Collection Interface Array Operations - Collections

## The Set Interface - Collections

## Set Interface Basic Operations - Collections

## Set Interface Bulk Operations - Collections

## The List Interface - Collections

## Comparison to Vector - Collections

## Collection Oprerations - Collections

## Positional Access and Search Operations - Collections

## Iterators - Collections

## Range-View Operation - Collections

## List Algorithms - Collections

## The Queue Interface - Collections

## The Deque Interface - Collections

## The Deque Interface - Insert - Collections

## The Deque Interface - Remove - Collections

## The Deque Interface - Retrieve - Collections

## The Map Interface - Collections

## Map Interface Basic Operations - Collections

## Map Interface Bulk Operations - Collections

## Fancy Uses of Collection Views: Map Algebra - Collections

## Multimaps - Collections

## Object Ordering - Collections

## Map Interface Bulk Operations - Collections

## Collection Views - Collections

## Writing Your Own Comparable Types - Collections

## The SortedSet Interface - Collections

## Set Operations - Collections

## Range-view Operations - Collections

## The SortedMap Interface - Collections

## The SortedMap Interface - Collections


## Implementations - Collections

## Algorithms - Collections

## Custom Collection Implementations - Collections

## Interoperability - Collections

# Java Applets

## Defining an Applet Subclass - Java Applets

## Using JAR Files - Java Applets

## Packaging Progrmas in JAR Files - Java Applets

## Using JAR-related APIs - Java Applets



# Language Basics

## Comments - Language Basics

```java
//  comment

/* multi line comment */ 
```

## Primitive Data Types - Language Basics

```java
int
short
long
byte
```

```java
float
double
```

```java
boolean
```

## Arrays - Language Basics

```java
int[] array; //declare an array of integers

array = new int[10]; //create an array of integers
array[0] = 100; //initialize first element
array[1] = 200; //initialize second element
array[2] = 300; //initialize third element

int[] array = { //create and initialize an array
    100,200,300,
    400,500,600,
    700,800,900,1000
};
new int[] {17, 19, 23}; //initialize an anonymous array

array = new int[] {17, 19, 23};

// is shorthand for:

int [] anonymous = {17, 19, 23};
array = anonymous;

String[][] names = {
    {"Mr. ", "Mrs. ", "Ms. "},
    {"Smith", "Jones"}
};
```

## Copying Arrays - Language Basics
```java
class ArrayCopyDemo {
    public static void main(String[] args) {
        char[] copyFrom = { 'd', 'e', 'c', 'a', 'f', 'f', 'e',
        'i', 'n', 'a', 't', 'e', 'd' };
        char[] copyTo = new char[7];
        System.arraycopy(copyFrom, 2, copyTo, 0, 7);
        //char[] copyTo = java.util.Arrays.copyOfRange(copyFrom, 2, 9);
        System.out.println(new String(copyTo));
    }
}
```

## Array Sorting - Language Basics

```java
int[] array = {1, 2, 3, 4, 5};
java.util.Arrays.sort(array);
```

# Operators

## Casts - Operators
```java
double x = 9.997;
int nx = (int) x; //nx is 9
//round a floating-point number to the nearest integer
int nx = (int) Math.round(x); //nx is 10, round return long value
```

# Input and Output

## Reading Input - Input and Output

```java
import java.util.Scanner;
//Scanner plainly input
Scanner in = new Scanner(System.in);
System.out.print("What is your name?");
String name = in.nextLine(); //read words
String firstName = in.next(); //read a single word
int age = in.nextInt(); //read an integer

Console cons = System.console();
String username = cons.readLine("Username: ");
char[] password = cons.readPassword("Password: ");

java.lang.System
java.util.Scanner
java.io.Console
```

## File Input and Output - Input and Output

```java
java.util.Scanner
java.io.PrintWriter
java.nio.file.Paths

Scanner in = new Scanner(Paths.get("myfile.txt"));
PrintWriter out = new PrintWriter("myfile.txt");

Scanner in = new Scanner("myfile.txt"); //ERROR? the scanner will see ten characters of data.
```

# Control Flow Statements

## Expressions - Control Flow Statements

## Statements - Control Flow Statements

## Block Scope - Control Flow Statements


## Conditional Statements - Control Flow Statements
```java
if (condition) statement
if (condition){
    statement(s)
}
if (condition) statement1 else statement2

if (condition){
    statement(s)
} else {
    statement(s)
}
```
## Loops - Control Flow Statements
```java
while (condition) statement
while (condition) {
    statement(s)
}
do statement while (condition)
do {
    statement(s)
} while (condition)
```

## Determinate Loops - Control Flow Statements

```java
for (initialization; termination; increment) {
    statement(s)
}

for (int i=1; i<10; i++) {
    System.out.println("Count is: " + i);
}

//infinite loop
for ( ; ; ) {
    statement(s)
}
```

## The For Each Loop - Control Flow Statements

```java
for (variable : collection) statement
//iteration through Collections and arrays
int[] numbers = {1,2,3,4,5,6,7,8,9,10};
for (int item : numbers) {
    System.out.println("Count is: " + item);
}
```

## Switch Statement - Control Flow Statements

```java
public class SwitchDemo {
    public static void main(String[] args) {
        int month = 8;
        String monthString;
        switch (month) {
            case 1: monthString = "January";
            break;
            case 2: monthString = "February";
            break;
            case 3: monthString = "March";
            break;
            case 4: monthString = "April";
            break;
            case 5: monthString = "May";
            break;
            case 6: monthString = "June";
            break;
            case 7: monthString = "July";
            break;
            case 8: monthString = "August";
            break;
            case 9: monthString = "September";
            break;
            case 10: monthString = "October";
            break;
            case 11: monthString = "November";
            break;
            case 12: monthString = "December";
            break;
            default: monthString = "Invalid month";
            break;
        }
        System.out.println(monthString);
    }
}
```

```java
class SwitchDemo2 {
    public static void main(String[] args) {
        int month = 2;
        int year = 2000;
        int numDays = 0;
        switch (month) {
        case 1: case 3: case 5:
        case 7: case 8: case 10:
        case 12:
        numDays = 31;
        break;
        case 4: case 6:
        case 9: case 11:
        numDays = 30;
        break;
        case 2:
        if (((year % 4 == 0) &&
        !(year % 100 == 0))
        || (year % 400 == 0))
        numDays = 29;
        else
        numDays = 28;
        break;
        default:
        System.out.println("Invalid month.");
        break;
        }
        System.out.println("Number of Days = "
        + numDays);
    }
}
```

```java
public class StringSwitchDemo {
    public static int getMonthNumber(String month) {
        int monthNumber = 0;
        if (month == null) {
            return monthNumber;
        }
        switch (month.toLowerCase()) {
            case "january":
            monthNumber = 1;
            break;
            case "february":
            monthNumber = 2;
            break;
            case "march":
            monthNumber = 3;
            break;
            case "april":
            monthNumber = 4;
            break;
            case "may":
            monthNumber = 5;
            break;
            case "june":
            monthNumber = 6;
            break;
            case "july":
            monthNumber = 7;
            break;
            case "august":
            monthNumber = 8;
            break;
            case "september":
            monthNumber = 9;
            break;
            case "october":
            monthNumber = 10;
            break;
            case "november":
            monthNumber = 11;
            break;
            case "december":
            monthNumber = 12;
            break;
            default:
            monthNumber = 0;
            break;
        }
        return monthNumber;
    }
    public static void main(String[] args) {
        String month = "August";
        int returnedMonthNumber =
        StringSwitchDemo.getMonthNumber(month);
    
        if (returnedMonthNumber == 0) {
            System.out.println("Invalid month");
        } else {
            System.out.println(returnedMonthNumber);
        }
    }
}
```

## Break Statement - Control Flow Statements

```java
class BreakWithLabelDemo {
public static void main(String[] args) {
int[][] arrayOfInts = {
{ 32, 87, 3, 589 },
{ 12, 1076, 2000, 8 },
{ 622, 127, 77, 955 }
};
int searchfor = 12;
int i;
int j = 0;
boolean foundIt = false;
search:
for (i = 0; i < arrayOfInts.length; i++) {
for (j = 0; j < arrayOfInts[i].length;
j++) {
if (arrayOfInts[i][j] == searchfor) {
foundIt = true;
break search;
}
}
}
if (foundIt) {
System.out.println("Found " + searchfor + " at " + i + ", " + j);
} else {
System.out.println(searchfor + " not in the array");
}
}
}
This is the output of the program.
Found 12 at 1, 0
```

## Continue Statement - Control Flow Statements

## Return Statement - Control Flow Statements

# Classes and Objects

## Declaring Classes - Classes and Objects

## Declaring Member Variables Fields - Classes and Objects

## Defining Methods - Classes and Objects

## Overloading Methods - Classes and Objects

## Creating Objects - Classes and Objects

## Using Objects - Classes and Objects

## More on Classes - Classes and Objects

## Returning a Value from a Method - Classes and Objects

## Returning a Value from a Method - Classes and Objects

## Nested Classes - Classes and Objects

## Enum Types - Classes and Objects

# Interfaces and Inheritance

## Interfaces - Interfaces and Inheritance

## Defining an Interface - Interfaces and Inheritance

## Implementing an Interface - Interfaces and Inheritance

## Using an Interface as a Type - Interfaces and Inheritance

## Rewriting Interfaces - Interfaces and Inheritance

## Inheritance - Interfaces and Inheritance

## Overriding and Hiding Methods - Interfaces and Inheritance

## Polymorphism - Interfaces and Inheritance

## Object as a Superclass - Interfaces and Inheritance

## Abstract Methods and Classes - Interfaces and Inheritance

# Numbers and Strings

## Numbers - Numbers and Strings

## The Numbers Classes - Numbers and Strings

## Formating Numeric Print Output - Numbers and Strings

## The DecimalFormat Class - Numbers and Strings

## Beyond Basic Arithmetic - Numbers and Strings

# Characters

# Strings

## Converting Between Numbers and Strings - Strings

## Manipulating Characters in a String - Strings

## Comparing Strings and Portions of Strings - Strings

## The StringBuilder Class - Strings

# Autoboxing and Unboxing

## Autoboxing - Autoboxing and Unboxing

## Unboxing - Autoboxing and Unboxing

# Generics

## Generic Types - Generics

## A Simple Box Class - Generics

## A Generic Version of the Box Class - Generics

## Type Parameter Naming Conventions - Generics

## Invoking and Instantiating a Generic Type - Generics

## The Diamond - Generics

## Multiple Type Parameters - Generics

## The Diamond - Generics

## Parameterized Types - Generics

## Raw Types - Generics

## Generic Methods - Generics

## Bounded Type Parameters - Generics

## Multiple Bounds - Generics

## Generic Methods and Bounded Type Parameters - Generics

## Generics, Inheritance, and Subtypes - Generics

## Generic Classes and Subtyping - Generics

## Type Inference - Generics

## Type Inference and Generic Contructors of Generic and Non-Generic Classes - Generics

## Wildcards - Generics

## Upper Bounded Wildcards - Generics

## Unbounded Wildcards - Generics

## Lower Bounded Wildcards - Generics

## Wildcards and Subtyping - Generics

## Wildcard Capture and Helper Methods - Generics

## Type Erasure - Generics

## Effects of Type Erasure and Bridge Methods - Generics

# Packages

## Using Package Memebers - Packages

## Refer to the member by its fully qualified name - Packages

## Import the package member - Packages

## Import the member’s entire package - Packages

## Apparent Hierarchies of Packages - Packages

## Name Ambiguities - Packages

## The Static Import Statement - Packages

## The Static Import Statement - Packages

# Essential Java Class

# Exceptions

## Catching and Handling Exceptions - Exceptions

## The Try Block - Exceptions

## The Catch Blocks - Exceptions

## The finally Block - Exceptions

## The try-with-resources Statement - Exceptions

## Putting It All Together - Exceptions

## Specifying the Exceptions Thrown by a Method - Exceptions

## How to Throw Exceptions - Exceptions

## Chained Exceptions - Exceptions

## Accessing Stack Trace Information - Exceptions

## Logging API - Exceptions

## Creating Exception Classes - Exceptions

# Basic I/O

## Using Byte Streams - Basic I/O

## Character Streams - Basic I/O

## Using Character Streams - Basic I/O

## Line-Oriented I/O - Basic I/O

## Buffered Streams - Basic I/O

## Scanning and Formatting - Scanning - Breaking Input into Tokens - Basic I/O

## Scanning and Formatting - Scanning - Translating Individual Tokens - Basic I/O

## Scanning and Formatting - Formatting - Basic I/O

## I/O from the Command Line - Basic I/O

## Standard Streams - Basic I/O

## The Console - Basic I/O

## Data Streams - Basic I/O

## Object Streams - Basic I/O

# File I/O

## Creating a Path - File I/O

## Retrieving Information about a Path - File I/O

## Converting a Path - File I/O

## Creating a Path Between Two Paths - File I/O

## Comparing Two Paths - File I/O

## Catching Exceptions - File I/O

## Varargs - File I/O

## Method Chaining - File I/O

## Verifying the Existence of a File or Directory - File I/O

## Checking File Accessibility - File I/O

## Checking Whether Two Paths Locate the Same File - File I/O

## Deleting a File or Directory - File I/O

## Copying a File or Directory - File I/O

## Moving a File or Directory - File I/O

## Managing Metadata - File I/O

## The OpenOptions Parameter - File I/O

## Commonly Used Methods for Small Files - File I/O

## Buffered I/O Methods for Text Files - File I/O

## Methods for Unbuffered Streams and Interoperable with java.io APIs - File I/O

## Methods for Channels and ByteBuffers - File I/O

## Methods for Creating Regular and Temporary Files - File I/O

## Random Access Files - File I/O

## Listing a File System’s Root Directories - File I/O

## Creating a Directory - File I/O

## Creating a Temporary Directory - File I/O

## Listing a Directory’s Contents - File I/O

## Filtering a Directory Listing By Using Globbing - File I/O

## Writing Your Own Directory Filter - File I/O

## Links, Symbolic or Otherwise - File I/O

## Creating a Symbolic Link - File I/O

## Creating a Hard Link - File I/O

## Detecting a Symbolic Link - File I/O

## Detecting a Symbolic Link - File I/O

## Finding the Target of a Link - File I/O

## Walking the File Tree - The FileVisitor Interface - File I/O

## Kickstarting the Process - The FileVisitor Interface - File I/O

## Considerations When Creating a FileVisitor - The FileVisitor Interface - File I/O

## Controlling the Flow - The FileVisitor Interface - File I/O

## Finding Files - The FileVisitor Interface - File I/O

## Watch Service Overview - Watching a Directory for Changes - File I/O

## Legacy File I/O Code


# Concurrency

## Defining and Starting a Thread - Concurrency

## Provide a Runnable object - Concurrency

## Subclass Thread - Concurrency

## The SimpleThreads Example - Concurrency

## The SimpleThreads Example - Concurrency

## Immutable Objects - Concurrency

## A Synchronized Class Example - Concurrency

## A Strategy for Defining Immutable Objects - Concurrency

## Lock Objects - High Level Concurrency Objects - Concurrency

## Lock Objects - High Level Concurrency Objects - Concurrency

# The Platform Environment

## Setting Up the Properties Object - The Platform Environment

## Saving Properties - The Platform Environment

## Command-Line Arguments - The Platform Environment

## Echoing Command-Line Arguments - The Platform Environment

## Parsing Numeric Command-Line Arguments - The Platform Environment

## Querying Environment Variables - The Platform Environment

## System Utilities - The Platform Environment

## Reading System Properties - The Platform Environment

## Writing System Properties - The Platform Environment

## PATH and CLASSPATH - The Platform Environment

## Checking the CLASSPATH variable (All platforms) - The Platform Environment

## Update the PATH Variable (Solaris and Linux) - The Platform Environment

# Regular Expressions

## Test Harness - Regular Expressions

## Using the split (String) Method - Regular Expressions

# Collections

## Interfaces - Collections

## The Collection Interface - Collections

## for-each Construct - Collections

## Iterators - Collections

## Collection Interface Bulk Operations - Collections

## Collection Interface Array Operations - Collections

## The Set Interface - Collections

## Set Interface Basic Operations - Collections

## Set Interface Bulk Operations - Collections

## The List Interface - Collections

## Comparison to Vector - Collections

## Collection Oprerations - Collections

## Positional Access and Search Operations - Collections

## Iterators - Collections

## Range-View Operation - Collections

## List Algorithms - Collections

## The Queue Interface - Collections

## The Deque Interface - Collections

## The Deque Interface - Insert - Collections

## The Deque Interface - Remove - Collections

## The Deque Interface - Retrieve - Collections

## The Map Interface - Collections

## Map Interface Basic Operations - Collections

## Map Interface Bulk Operations - Collections

## Fancy Uses of Collection Views: Map Algebra - Collections

## Multimaps - Collections

## Object Ordering - Collections

## Map Interface Bulk Operations - Collections

## Collection Views - Collections

## Writing Your Own Comparable Types - Collections

## The SortedSet Interface - Collections

## Set Operations - Collections

## Range-view Operations - Collections

## The SortedMap Interface - Collections

## The SortedMap Interface - Collections


## Implementations - Collections

## Algorithms - Collections

## Custom Collection Implementations - Collections

## Interoperability - Collections

# Java Applets

## Defining an Applet Subclass - Java Applets

## Using JAR Files - Java Applets

## Packaging Progrmas in JAR Files - Java Applets

## Using JAR-related APIs - Java Applets